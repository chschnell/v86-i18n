#!/bin/python

##
## import_cp.py
##
## Download raw files from www.unicode.org in this directory using:
##
##   wget --mirror --no-parent --reject "index.html*" https://www.unicode.org/Public/MAPPINGS/
##

import os, sys, json

VENDORS_DIR = 'www.unicode.org/Public/MAPPINGS/VENDORS'

def read_codepage_def(cp_filename, cp437_fallback=None):
    codepoints_defined = 0
    result = [0] * 256
    with open(cp_filename) as f_in:
        for line_no, line_in in enumerate(f_in):
            line_in = line_in.strip()
            if len(line_in) == 0 or line_in[0] == '#' or ord(line_in[0]) == 0x1a:
                ## 0x1a: ASCII ctrl char "SUB" (CTRL+Z), an end-of-file marker
                continue
            line = line_in.split('\t')
            if len(line) != 3:
                raise Exception(f'{cp_filename}:{line_no}: unexpected line format: {line_in} {ord(line_in[0])}!')
            cp_char = int(line[0].strip(), 16)
            if cp_char > 255:
                raise Exception(f'{cp_filename}:{line_no}: invalid character code {cp_char}!')
            codepoint = line[1].strip()
            if codepoint == '':
                ## map undefined codepoints to CP437, or (should not happen): replacement character U+FFFD
                codepoint = cp437_fallback[cp_char] if cp437_fallback else 0xfffd
            else:
                codepoint = int(codepoint, 16)
                if codepoint > 0xffff:
                    raise Exception(f'{cp_filename}:{line_no}: invalid codepoint {codepoint}!')
            result[cp_char] = codepoint
            codepoints_defined += 1
    if codepoints_defined != 256:
        raise Exception(f'{cp_filename}: unexpected number of codepoint defintions {codepoints_defined}!')
    return result[ 128 : ] if cp437_fallback else result

def main():
    cp437_file = f'{VENDORS_DIR}/MICSFT/PC/CP437.TXT'
    cp437 = read_codepage_def(cp437_file)

    ibmgraph_file = f'{VENDORS_DIR}/MISC/IBMGRAPH.TXT'
    with open(ibmgraph_file) as f_in:
        for line_no, line_in in enumerate(f_in):
            if line_in[0] == '#':
                continue
            line = line_in.rstrip().split('\t')
            if len(line) != 5:
                raise Exception(f'{ibmgraph_file}:{line_no}: unexpected line format: {line_in}!')
            codepoint = int(line[0], 16)
            cp_char = int(line[1], 16)
            if cp_char > 0x7F:
                ## Skipped from IBMGRAPH.TXT:
                ##   0xB9: 0x2563
                ##   0xBA: 0x2551
                ##   0xBB: 0x2557
                ##   0xBC: 0x255D
                ##   0xC8: 0x255A
                ##   0xC9: 0x2554
                ##   0xCA: 0x2569
                ##   0xCB: 0x2566
                ##   0xCC: 0x2560
                ##   0xCD: 0x2550
                ##   0xCE: 0x256C
                continue
            cp437[cp_char] = codepoint

    ## CP932, CP936, CP949 and CP950 don't contain any useful mappings but Unicode codepoints
    skip_codepages = ['CP437', 'CP932', 'CP936', 'CP949', 'CP950']
    ## codepages: dict(str cp_name => array codepage[128 or 256 * Uint8])
    codepages = {'CP437': cp437}

    for path in [f'{VENDORS_DIR}/MICSFT/PC', f'{VENDORS_DIR}/MICSFT/WINDOWS']:
        for dirpath, dirnames, filenames in os.walk(path):
            for filename in filenames:
                filename = filename.upper()
                cp_name = filename[ : -4 ]
                if not filename.endswith('.TXT') or cp_name in skip_codepages:
                    continue
                codepage = read_codepage_def(f'{dirpath}/{filename}', cp437)
                codepages[cp_name] = codepage
                if cp_name == 'CP850':
                    ## CP858 is derived from CP850 and differs only at 0xD5:
                    ## former "dotless i" U+0131 is replaced by "euro symbol" U+20AC
                    cp858 = codepage.copy()
                    cp858[0xD5 - 128] = 0x20AC
                    codepages['CP858'] = cp858

    sorted_cp_ids = sorted(codepages.keys(), key=lambda k: int(k[2:]))

    print('/*')
    print(f'NOTE: This file was auto-generated by {os.path.basename(__file__)}!\n')
    print('Exports mapping tables from 8-bit Code Page character codes to their')
    print('respective UTF-8 strings. Supported Code Pages:\n')
    line_len = 0
    for cp_name in sorted_cp_ids:
        cp_name_len = len(cp_name)
        if line_len + cp_name_len + 2 < 70:
            if line_len == 0:
                print(f'    {cp_name}', end='')
                line_len = 4 + cp_name_len
            else:
                print(f', {cp_name}', end='')
                line_len += 2 + cp_name_len
        else:
            print(f',\n    {cp_name}', end='')
            line_len = 4 + cp_name_len
    print('\n\nSOURCE\n')
    print('    http://www.unicode.org/Public/MAPPINGS/')
    print('*/\n')

    last_i_cp = len(sorted_cp_ids) - 1
    print('export const CODEPAGE_TABLES = {')
    for i_cp, cp_name in enumerate(sorted_cp_ids):
        codepoints_str = ''.join([chr(codepoint) for codepoint in codepages[cp_name]])
        codepoints_json = json.dumps(codepoints_str, ensure_ascii=False)
        print(f'    {cp_name.lower()}: {codepoints_json}', end='\n' if i_cp == last_i_cp else ',\n')
    print('};')

if __name__ == '__main__':
    sys.stdout.reconfigure(encoding='utf-8')
    main()
